# 基于 Flask 和 SQUARE 的众包数据质量评估系统设计与实现


---

## 摘要

随着众包模式在数据标注、内容审核等领域的广泛应用，如何评估和保证众包数据的质量成为一个重要挑战。SQUARE (Statistical Quality Assurance for Reliable Evaluation) 是一个用于评估不可靠标注者数据的统计质量保证框架，但其原始 Java 库通常需要通过命令行进行操作，对于非专业用户不够友好。

本项目设计并实现了一个基于 Flask Web 框架的众包数据质量评估系统。该系统旨在为 SQUARE Java 库提供一个图形化的用户界面，简化用户操作流程。用户可以通过网页选择数据集、配置评估方法（如多数投票、贝叶斯、Raykar、ZenCrowd）、设置 N-fold 交叉验证参数以及选择监督/非监督模式。系统后端负责调用 SQUARE Java 库执行评估任务，并将实时运行日志通过 Server-Sent Events (SSE) 推送至前端展示。评估完成后，系统会解析 SQUARE 生成的结果文件，提取关键评估指标（如准确率、精确率、召回率、F1 值），并在前端使用表格和 Chart.js 图表进行可视化展示，方便用户直观比较不同算法的效果。此外，系统还集成了基于 Flask-Login 和 Flask-SQLAlchemy 的用户注册和登录功能，保证了系统的安全性。

本论文详细介绍了系统的需求分析、整体架构设计、技术选型、前后端模块实现细节，包括 Flask 路由设计、用户认证流程、与 SQUARE Java 库的交互机制、数据解析与可视化方法等。最后，通过运行实例展示了系统的功能，并对系统进行了总结，指出了其优势、局限性和未来可改进的方向。

**关键词：** 众包；数据质量；标签聚合；SQUARE；Flask；Web 系统；数据可视化

---

## Abstract

With the widespread application of crowdsourcing in fields such as data annotation and content moderation, assessing and ensuring the quality of crowdsourced data has become a significant challenge. SQUARE (Statistical Quality Assurance for Reliable Evaluation) is a statistical quality assurance framework for evaluating data from unreliable annotators. However, its original Java library typically requires command-line operation, which is not user-friendly for non-specialists.

This project designs and implements a crowdsourced data quality assessment system based on the Flask web framework. The system aims to provide a graphical user interface for the SQUARE Java library, simplifying the user operation process. Users can select datasets, configure evaluation methods (e.g., Majority Vote, Bayes, Raykar, ZenCrowd), set N-fold cross-validation parameters, and choose supervised/unsupervised modes through the web interface. The system backend is responsible for invoking the SQUARE Java library to perform evaluation tasks and pushes real-time running logs to the frontend for display via Server-Sent Events (SSE). Upon completion of the evaluation, the system parses the result files generated by SQUARE, extracts key evaluation metrics (such as accuracy, precision, recall, F1-score), and presents them on the frontend using tables and Chart.js charts for visualization, allowing users to intuitively compare the effectiveness of different algorithms. Furthermore, the system integrates user registration and login functions based on Flask-Login and Flask-SQLAlchemy, ensuring system security.

This thesis details the system's requirement analysis, overall architecture design, technology selection, and implementation details of frontend and backend modules, including Flask routing design, user authentication flow, interaction mechanism with the SQUARE Java library, data parsing, and visualization methods. Finally, the system's functionality is demonstrated through running examples, and the system is summarized, pointing out its advantages, limitations, and potential future improvements.

**Keywords:** Crowdsourcing; Data Quality; Label Aggregation; SQUARE; Flask; Web System; Data Visualization

---

## 目录

- [摘要](#摘要)
- [Abstract](#abstract)
- [目录](#目录)
- [图目录](#图目录) (如果需要)
- [表目录](#表目录) (如果需要)
- [第一章 绪论](#第一章-绪论)
    - [1.1 研究背景与意义](#11-研究背景与意义)
    - [1.2 国内外研究现状](#12-国内外研究现状)
    - [1.3 研究内容](#13-研究内容)
    - [1.4 技术路线](#14-技术路线)
    - [1.5 论文结构](#15-论文结构)
- [第二章 相关技术概述](#第二章-相关技术概述)
    - [2.1 众包与数据质量](#21-众包与数据质量)
    - [2.2 标签聚合算法](#22-标签聚合算法)
        - [2.2.1 多数投票 (Majority Vote)](#221-多数投票-majority-vote)
        - [2.2.2 贝叶斯方法 (Bayesian Methods)](#222-贝叶斯方法-bayesian-methods)
        - [2.2.3 EM 算法（Raykar, ZenCrowd 等）](#223-em-算法raykar-zencrowd-等)
    - [2.3 SQUARE 框架介绍](#23-square-框架介绍)
    - [2.4 Web 开发技术](#24-web-开发技术)
        - [2.4.1 Flask 框架](#241-flask-框架)
        - [2.4.2 HTML/CSS/JavaScript](#242-htmlcssjavascript)
        - [2.4.3 Bootstrap](#243-bootstrap)
        - [2.4.4 Chart.js](#244-chartjs)
        - [2.4.5 Server-Sent Events (SSE)](#245-server-sent-events-sse)
    - [2.5 数据库技术](#25-数据库技术)
        - [2.5.1 SQLAlchemy](#251-sqlalchemy)
        - [2.5.2 SQLite](#252-sqlite)
    - [2.6 本章小结](#26-本章小结)
- [第三章 系统设计](#第三章-系统设计)
    - [3.1 系统需求分析](#31-系统需求分析)
        - [3.1.1 功能需求](#311-功能需求)
        - [3.1.2 非功能需求](#312-非功能需求)
    - [3.2 系统总体架构](#32-系统总体架构)
    - [3.3 技术选型](#33-技术选型)
    - [3.4 功能模块设计](#34-功能模块设计)
        - [3.4.1 用户认证模块](#341-用户认证模块)
        - [3.4.2 参数配置模块](#342-参数配置模块)
        - [3.4.3 算法执行模块](#343-算法执行模块)
        - [3.4.4 结果展示模块](#344-结果展示模块)
    - [3.5 数据库设计](#35-数据库设计)
    - [3.6 接口设计](#36-接口设计)
    - [3.7 本章小结](#37-本章小结)
- [第四章 系统实现](#第四章-系统实现)
    - [4.1 开发环境](#41-开发环境)
    - [4.2 后端实现 (`app.py`)](#42-后端实现-apppy)
        - [4.2.1 Flask 应用初始化与配置](#421-flask-应用初始化与配置)
        - [4.2.2 用户模型与数据库操作](#422-用户模型与数据库操作)
        - [4.2.3 用户认证路由实现 (注册、登录、登出)](#423-用户认证路由实现-注册登录登出)
        - [4.2.4 主页与参数提交路由 (`/`, `/run_java_algorithm_stream`)](#424-主页与参数提交路由--run_java_algorithm_stream)
        - [4.2.5 Java 子进程调用与日志流处理](#425-java-子进程调用与日志流处理)
        - [4.2.6 结果获取与解析路由 (`/get_evaluation_results`)](#426-结果获取与解析路由-get_evaluation_results)
        - [4.2.7 路径构建与文件操作](#427-路径构建与文件操作)
    - [4.3 前端实现 (`templates/`)](#43-前端实现-templates)
        - [4.3.1 页面布局与样式 (HTML, CSS, Bootstrap)](#431-页面布局与样式-html-css-bootstrap)
        - [4.3.2 登录与注册页面实现 (`login.html`, `register.html`)](#432-登录与注册页面实现-loginhtml-registerhtml)
        - [4.3.3 主页面实现 (`index.html`)](#433-主页面实现-indexhtml)
        - [4.3.4 JavaScript 交互逻辑](#434-javascript-交互逻辑)
            - [4.3.4.1 参数获取与动态表单](#4341-参数获取与动态表单)
            - [4.3.4.2 算法运行请求 (`runAlgorithm`)](#4342-算法运行请求-runalgorithm)
            - [4.3.4.3 SSE 日志接收与展示](#4343-sse-日志接收与展示)
            - [4.3.4.4 结果获取请求 (`getEvaluationResults`)](#4344-结果获取请求-getevaluationresults)
            - [4.3.4.5 表格渲染 (`displayEvaluationResults`)](#4345-表格渲染-displayevaluationresults)
            - [4.3.4.6 图表绘制 (`drawCharts`)](#4346-图表绘制-drawcharts)
        - [4.3.5 CDN 国内源替换](#435-cdn-国内源替换)
    - [4.4 本章小结](#44-本章小结)
- [第五章 系统测试与结果分析](#第五章-系统测试与结果分析)
    - [5.1 测试环境](#51-测试环境)
    - [5.2 功能测试](#52-功能测试)
        - [5.2.1 用户注册与登录测试](#521-用户注册与登录测试)
        - [5.2.2 参数配置与算法运行测试](#522-参数配置与算法运行测试)
        - [5.2.3 日志流输出测试](#523-日志流输出测试)
        - [5.2.4 结果展示与可视化测试](#524-结果展示与可视化测试)
    - [5.3 运行实例与结果分析](#53-运行实例与结果分析)
        - [5.3.1 场景一：非监督模式 + HCB 数据集 + All 方法](#531-场景一非监督模式--hcb-数据集--all-方法)
        - [5.3.2 场景二：监督模式 + HCBHCB3 数据集 + Majority 方法 + 10-fold](#532-场景二监督模式--hcbhcb3-数据集--majority-方法--10-fold)
        - [5.3.3 结果对比分析](#533-结果对比分析)
    - [5.4 本章小结](#54-本章小结)
- [第六章 总结与展望](#第六章-总结与展望)
    - [6.1 工作总结](#61-工作总结)
    - [6.2 系统特点与创新](#62-系统特点与创新)
    - [6.3 局限性分析](#63-局限性分析)
    - [6.4 未来工作展望](#64-未来工作展望)
- [参考文献](#参考文献)
- [致谢](#致谢)
- [附录](#附录) (可选，如关键代码片段、配置文件示例等)

---

## 第一章 绪论

### 1.1 研究背景与意义

随着互联网的高速发展以及众包平台（如 Amazon Mechanical Turk、Figure-Eight、问卷星等）的普及，越来越多的数据密集型任务被外包给大众完成。例如，在自然语言处理、计算机视觉和推荐系统等领域，大量的文本、图片、音频和视频标签都是通过众包手段获得的。众包标注具有低成本、高并发和可扩展等优势，但也面临标注者水平参差不齐、主观性强、甚至恶意标注等问题，导致数据质量难以保证。

数据质量直接影响后续机器学习模型的训练效果和业务决策的准确性。因此，**如何评估并提升众包数据的质量**成为学术界和工业界共同关注的研究热点。SQUARE（Statistical Quality Assurance for Reliable Evaluation）框架基于统计推断思想，通过对工人可靠度建模、标签聚合以及误差估计，能够有效评估低信任度标注者生成的数据。但 SQUARE 原生实现为 Java 库且主要通过命令行调用，使用门槛相对较高，不利于非专业技术人员快速上手。

为此，本文在 SQUARE 的基础上构建了一个可视化、易操作的 Web 系统，利用 Flask 提供直观友好的交互界面，将复杂的命令行参数配置、评估结果解析和可视化过程自动化，显著降低了 SQUARE 在科研及实际项目中的使用难度，具有重要的应用价值和推广意义。

### 1.2 国内外研究现状

在众包数据质量控制领域，国内外学者提出了多种解决方案。从算法角度，早期方法以**多数投票（Majority Vote）**为代表，通过简单统计选择出现频次最高的标签。然而该方法无法区分工人质量差异，对噪声敏感。随后，学者们引入**贝叶斯模型**、**EM（Expectation-Maximization）**框架，对工人可靠度和任务难度进行建模，典型工作包括 Dawid & Skene 模型、Raykar 模型以及 ZenCrowd 等。这些算法在假设条件、收敛速度及可解释性方面各有优势。

在系统层面，国外出现了如 CrowdTruth、CrowdFlower Quality Control 等平台，提供一定程度的质量评估功能，但往往与具体算法耦合度高，缺乏灵活性；国内相关开源系统较少，多集中于业务场景定制。本项目基于开源的 SQUARE 框架，充分继承其算法完整性与灵活性，并通过二次开发实现 Web 化、可视化和易用性提升，为众包质量评估工具提供了新的实现范式。

### 1.3 研究内容

围绕"降低 SQUARE 使用门槛、提升众包数据质量评估效率"这一目标，本文主要开展以下工作：

1. 需求分析：梳理众包质量评估流程与用户痛点，明确系统需支持的数据集管理、算法选择、交叉验证、实时监控、结果可视化等功能。
2. 系统设计：提出基于 Flask 的前后端分离式整体架构，规划用户认证、参数配置、算法执行、结果展示四大核心模块，并设计数据库模式与接口协议。
3. 系统实现：
   * 后端使用 Flask-Login、Flask-SQLAlchemy 实现用户管理，利用 `subprocess` 调用 SQUARE Java 程序，并通过 SSE 技术实时推送日志；
   * 前端采用 Bootstrap 构建响应式界面，使用 JavaScript + Chart.js 实现结果表格与图表渲染；
   * 完成对 Majority、Bayes、Raykar、ZenCrowd 四种算法及监督/非监督/N-fold 等运行模式的支持。
4. 系统测试与评估：设计多组实验场景，对不同算法和参数组合进行验证，分析系统稳定性与可视化效果。
5. 论文撰写：总结设计思路、关键技术与实验结论，提出改进方向。

### 1.4 技术路线

项目技术路线如图 1-1 所示，可分为数据层、业务层与表示层：

* **数据层**：采用 SQLite 作为持久化存储，通过 SQLAlchemy ORM 管理用户信息和运行记录，减少数据库运维成本。
* **业务层**：
  * Flask 负责 HTTP 请求路由、会话管理和权限控制；
  * 通过 `subprocess.Popen` 启动 SQUARE Java 进程，并使用跨平台的 `classpath` 组织方式；
  * 解析 SQUARE 输出文件，生成统一的 JSON 数据结构；
  * 使用 SSE 将实时日志流发送给前端，提升用户体验。
* **表示层**：
  * 前端基于 Bootstrap 实现自适应布局；
  * 通过原生 Fetch API 进行异步通信；
  * 采用 Chart.js 绘制柱状图直观展示评估指标对比；
  * 对国内用户，静态资源链接切换为 BootCDN，提高加载速度。

整个开发流程遵循 **需求分析 → 系统设计 → 模块编码 → 集成测试 → 部署上线 → 文档撰写** 的迭代式方法，保证了系统的可维护性与可扩展性。

### 1.5 论文结构

全文共分六章：

* **第一章 绪论**：介绍研究背景、意义、国内外现状，阐述本文的研究内容、技术路线与章节安排。
* **第二章 相关技术概述**：回顾众包数据质量控制、标签聚合算法与 Web 开发相关技术，为后续实现奠定理论基础。
* **第三章 系统设计**：从需求分析出发，给出系统整体架构、功能模块、数据库及接口设计。
* **第四章 系统实现**：结合关键代码，详细说明后端核心逻辑、前端交互实现与算法集成细节。
* **第五章 系统测试与结果分析**：通过多组实验验证系统功能与性能，分析不同算法在真实/模拟数据集上的效果。
* **第六章 总结与展望**：总结本文工作成果与创新点，反思不足，并展望未来改进方向。

---

## 第二章 相关技术概述

### 2.1 众包与数据质量

众包（Crowdsourcing）是一种将任务分发给互联网大众、利用群体智慧完成目标的协作模式。典型应用场景包括文本情感标注、图像目标识别、语音转录、问卷调查、地图标注等。相较于传统专家标注，众包拥有成本低、速度快、可伸缩性好等优势，但也带来数据噪声大、标注者能力异质、甚至存在恶意标注的挑战。学者通常从**准确性（Accuracy）**、**一致性（Consistency）**与**覆盖度（Coverage）**等维度衡量众包数据质量。当众包标注直接用于训练机器学习模型或业务决策时，若缺乏有效的质量控制和评估机制，将导致模型性能下降乃至产生错误结论。因此，建立一套系统化的数据质量评估与提升框架对众包应用至关重要。

### 2.2 标签聚合算法

标签聚合（Label Aggregation）旨在根据多个工人的标注推断问题的真实标签，同时估计工人的可靠性。常见算法可分为三类：

**2.2.1 多数投票（Majority Vote）**  
最简单的聚合方式，将出现次数最多的标签作为最终答案。其实现成本低、易于解释，但无法区分工人能力差异，容易受到噪声干扰，特别是在类别分布不均或少数派标签极为重要的任务中效果欠佳。

**2.2.2 贝叶斯方法（Bayesian Methods）**  
贝叶斯框架通过先验分布与似然函数建模工人行为与任务难度。经典的 Dawid & Skene 模型假设每位工人具有固定的混淆矩阵，通过 EM 算法迭代估计混淆矩阵与真实标签。SQUARE 中的 BayesGeneralized 模块更进一步，引入拉普拉斯平滑项 (lapAlpha、lapBeta) 处理数据稀疏问题，并采用 One-vs-All 方式解决多分类场景。

**2.2.3 EM 系列算法（Raykar、ZenCrowd 等）**  
此类方法同样使用 EM 思想，但在模型假设与参数更新策略上更为灵活。例如 Raykar 算法同时学习工人可靠度与类别先验概率；ZenCrowd 在期望步中引入类别难度参数，在最大化步更新工人准确率。相比多数投票，EM 算法能够有效提升聚合精度；相比贝叶斯模型，其对先验依赖较小，但需要更多迭代计算。

### 2.3 SQUARE 框架介绍

SQUARE（Statistical Quality Assurance for Reliable Evaluation）是麻省理工学院开发的开源质量评估框架，目标是为众包标注任务提供**统一、可扩展**的计算评估平台。其设计理念包括：

1. **算法抽象化**：通过 `AlgorithmInterface` 与 `ExtendedAlgorithmInterface` 定义统一 API，便于接入不同聚合算法。
2. **多模式支持**：框架支持无监督、半监督、监督三种模式，并可配合 N-fold 交叉验证评估算法性能。
3. **灵活 I/O**：采用文本文件描述工人标注、类别集合与标准答案；运行结束后生成标准格式的结果与统计文件，方便二次处理。
4. **可扩展性**：用户可自行实现算法模块并在命令行参数中指定 `--method` 进行调用。

在本项目中，SQUARE 通过 Java 进程嵌入的方式与 Flask 后端集成，实现了 Majority、Bayes、Raykar、ZenCrowd 四种算法的一键调用。

### 2.4 Web 开发技术

**Flask 框架**  
Flask 是 Python 生态中轻量级 Web 框架的代表，遵循 WSGI 规范，内置路由、模板渲染 (Jinja2)、上下文管理等核心功能，易于扩展。项目基于 Flask 构建 RESTful 接口，并结合 Flask-Login 完成用户认证，Flask-SQLAlchemy 完成 ORM 操作。

**HTML/CSS/JavaScript**  
三者共同完成浏览器端的结构、样式与交互逻辑。项目中 HTML 通过 Jinja2 动态渲染，CSS 借助 Bootstrap 提供的栅格系统与组件快速完成页面布局，JavaScript 负责表单交互、异步请求与数据可视化。

**Bootstrap**  
Bootstrap 4/5 提供响应式设计和大量预置样式组件。系统页面（登录、注册、主页面）均使用卡片 (Card)、导航栏 (Navbar)、表单组 (Form Group) 等组件，确保在 PC 与移动端均有良好体验。

**Chart.js**  
Chart.js 是轻量级前端图表库，支持柱状图、折线图、饼图等多种类型。本文使用柱状图对不同算法指标进行对比，可通过简洁 API 与自定义配色实现快速渲染。

**Server-Sent Events (SSE)**  
SSE 允许服务器以文本流的方式持续向浏览器推送数据，适合一方向、实时性要求高的场景。本系统利用 SSE 将 Java 进程输出的日志行实时发送到前端，用户无需刷新即可查看算法运行进度。

### 2.5 数据库技术

**SQLAlchemy**  
SQLAlchemy 是 Python 主流 ORM 框架，其声明式模型 (Declarative) 使开发者可以使用面向对象方式操作数据库，同时屏蔽底层 SQL 差异。结合 Flask-SQLAlchemy，项目只需几行代码即可完成数据库连接、模型定义与会话管理。

**SQLite**  
SQLite 是轻量级关系型数据库，零配置、跨平台、文件级存储适合中小型 Web 应用。本项目用于存储用户信息及运行记录，无需部署独立数据库服务即可满足需求。

### 2.6 本章小结

本章对本研究所涉及的众包数据质量评估理论、标签聚合算法、SQUARE 框架和 Web 技术栈进行了系统梳理。通过对相关技术的比较与分析，为后续系统设计与实现奠定了理论与工具基础。

---

## 第三章 系统设计

### 3.1 系统需求分析

为了实现对众包数据质量的可视化评估，系统需满足**功能性**与**非功能性**两大类需求。

（一）功能需求

1. **用户管理**：支持注册、登录、退出登录与会话保持，确保未认证用户无法访问核心功能页面；
2. **实验配置**：前端页面允许用户选择数据集、算法方法、监督方式以及 N-fold 交叉验证参数；
3. **任务调度**：后端根据用户配置生成 SQUARE 命令参数与配置文件，启动 Java 进程执行算法；
4. **实时监控**：利用 SSE 技术实时推送 Java 进程标准输出，前端即时滚动显示日志；
5. **结果管理**：后端在算法结束后解析 SQUARE 结果文件，将评估指标封装为 JSON；
6. **数据可视化**：前端将指标以表格和柱状图两种形式展示，并在不同算法间对齐指标维度，便于直观比较。

（二）非功能需求

1. **易用性**：界面友好、交互简洁，即使对 SQUARE 不熟悉的用户也能快速上手；
2. **可靠性**：系统能够识别并提示常见错误，如参数缺失、结果目录不存在、Java 运行异常等；
3. **安全性**：采用加盐哈希方式保存用户密码，通过 Flask-Login 控制访问权限；
4. **性能**：日志推送延迟控制在 1s 内，评估结果解析时间控制在 100ms 量级；
5. **可维护性**：模块划分清晰，新增算法或数据集时只需在少量文件中修改即可生效。

### 3.2 系统总体架构

系统采用**前后端分离 + 进程调用**的分层架构，如图 3-1 所示（示意图可在最终定稿中绘制）：

1. **表示层（Presentation）**：由 HTML + Bootstrap 编写的响应式页面与原生 JavaScript 组成，负责用户交互与可视化展示；
2. **业务逻辑层（Service）**：基于 Flask 的 RESTful API，包含路由转发、参数校验、用户认证及日志推送；
3. **算法执行层（Execution）**：通过 `subprocess.Popen` 调用 SQUARE Java 库，负责真实的标签聚合计算；
4. **数据访问层（Data Access）**：使用 SQLAlchemy 对 SQLite 进行 ORM 操作，持久化用户与实验元数据。

模块间通过 JSON 进行数据交换，降低了语言与进程间耦合度。

### 3.3 技术选型

技术选型依据"**开发效率**、**社区活跃度**、**学习成本**"三大指标综合评估：

| 层次          | 技术             | 选型理由                                      |
|--------------|----------------|---------------------------------------------|
| 表示层        | Bootstrap 4/5   | 开箱即用的栅格系统与组件，提升开发效率          |
| 表示层        | Chart.js        | 轻量级、API 简单，可快速生成统计图表           |
| 业务逻辑层    | Flask           | 微框架，灵活可插拔，生态完善                   |
| 业务逻辑层    | Flask-Login     | 官方维护的认证扩展，实现登录态管理              |
| 业务逻辑层    | Flask-SQLAlchemy| 统一 ORM 接口，简化数据库操作                  |
| 算法执行层    | Java 17 + SQUARE| 继承原生算法性能与稳定性                      |
| 数据访问层    | SQLite          | 无需独立服务，部署成本低                      |

### 3.4 功能模块设计

（一）用户认证模块

用户模型仅包含 `id`、`username`、`password_hash` 字段。密码通过 Werkzeug 的 `generate_password_hash` 与 `check_password_hash` 进行加盐哈希与验证，防止明文存储。所有核心路由均用 `@login_required` 装饰器保护。

（二）参数配置模块

`index.html` 提供四个下拉框：**估计方法 (estimation)**、**算法方法 (method)**、**数据集 (dataset)**、**N-fold (nfold)**。当用户选择 `unsupervised` 时自动隐藏 nfold 选项；当切换算法方法时自动更新提示信息。

（三）算法执行模块

后端根据参数生成如 `--responses`、`--method` 等命令行，写入配置文件，再通过 `subprocess.Popen` 启动如下命令：

```bash
java -Xmx2048m -ea -cp <classpath> org.square.qa.analysis.Main --file <configFile>
```

日志逐行读取并封装为 `data:` 开头的 SSE 事件推送给浏览器，从而实现无刷新实时输出。

（四）结果展示模块

SQUARE 结束后在指定 `saveDir` 生成 `*_results.txt`。后端扫描文件夹、解析以 `%` 开头的头部行与数据行，归一化为

```json
{
  "method": "Majority",
  "headers": ["% Accuracy\tPrecision..."],
  "data": ["0.88\t0.81\t..."]
}
```

前端将表格与图表放置在 Tab 容器中，用户可切换查看训练/测试集指标。

### 3.5 数据库设计

数据库采用单表结构 `t_user`：

| 字段名   | 类型      | 约束            | 说明         |
|---------|----------|----------------|-------------|
| id      | Integer  | 主键、自增      | 用户唯一编号   |
| username| String(80)| 唯一、非空      | 登录账户名     |
| password_hash | String(128)| 非空  | 密文密码      |

如需记录实验历史，可扩展 `t_job` 表包含 `user_id`、`dataset`、`method`、`start_time`、`status` 等字段。

### 3.6 接口设计

| 路径                         | 方法 | 描述                          | 请求参数 (JSON)                           | 返回              |
|-----------------------------|------|-----------------------------|-------------------------------------------|------------------|
| `/run_java_algorithm_stream`| POST | 启动算法并建立 SSE 连接        | estimation, dataset, nfold, method        | `text/event-stream`|
| `/get_evaluation_results`   | POST | 获取结果文件并解析             | 同上                                      | `{results: []}`   |
| `/login`                    | POST | 用户登录                     | username, password                        | 302 / JSON        |
| `/register`                 | POST | 用户注册                     | username, password, confirm_password      | 302 / JSON        |
| `/logout`                   | GET  | 退出登录                     | –                                         | 302              |

接口采用统一的错误码和消息字段，确保前端能够友好提示。

### 3.7 本章小结

本章从需求、架构、技术选型、功能模块、数据库与接口六个维度系统地阐述了众包数据质量评估 Web 系统的设计方案。通过合理的分层与模块划分，为后续实现奠定了坚实基础。

---

## 第四章 系统实现

*   本章结合代码详细介绍各模块的实现。

### 4.1 开发环境

*   操作系统、Python 版本、Flask 及相关库版本、Java 版本、数据库、开发工具 (VSCode/Cursor)。

### 4.2 后端实现 (`app.py`)

*   **4.2.1 Flask 应用初始化与配置:** 创建 Flask app 实例、配置密钥、数据库 URI、初始化 Flask-SQLAlchemy 和 Flask-Login。
*   **4.2.2 用户模型与数据库操作:** `User` 类定义 (继承 `UserMixin`, `db.Model`)、密码设置/校验方法 (`set_password`, `check_password`)、数据库表创建 (`db.create_all()`)。
*   **4.2.3 用户认证路由实现:** `/login`, `/register`, `/logout` 路由函数逻辑，表单处理，用户查找，密码校验，`login_user`, `logout_user` 函数使用，`@login_required` 装饰器应用。
*   **4.2.4 主页与参数提交路由:** `/` 路由 (添加 `@login_required`)、`/run_java_algorithm_stream` 路由逻辑，获取 POST 请求 JSON 数据，解析参数 (`estimation`, `dataset`, `nfold`, `method`)。
*   **4.2.5 Java 子进程调用与日志流处理:** 生成 SQUARE 配置文件内容和文件名、使用 `subprocess.Popen` 启动 Java 进程、设置 `stdout`, `stderr`, `text=True`, `bufsize=1`、构建 `classpath` (注意跨平台分隔符)、定义 `generate` 生成器函数，`yield` SSE 格式数据。
*   **4.2.6 结果获取与解析路由:** `/get_evaluation_results` 路由逻辑，获取参数，构建结果文件路径 (考虑 `method` 参数)、使用 `os.path.exists`, `os.listdir`, `os.path.join` 操作文件、读取 `.txt` 文件内容、解析 Header 和 Data 行、处理异常、返回 JSON 响应 (包括错误处理和空结果处理)。
*   **4.2.7 路径构建与文件操作:** 确保 `saveDir` 等目录存在 (`os.makedirs(exist_ok=True)`)、配置文件写入 (`with open(...)`)。

### 4.3 前端实现 (`templates/`)

*   **4.3.1 页面布局与样式:** `base.html` (如果使用模板继承)、主要页面结构 (导航栏、卡片布局)、CSS 样式。
*   **4.3.2 登录与注册页面实现:** 表单设计、Jinja2 模板渲染 (如 `url_for`, `get_flashed_messages`)。
*   **4.3.3 主页面实现:** 参数选择表单 (下拉框)、日志显示区域 (`<pre id="result">`)、结果表格和图表容器 (`<div id="evaluation_results">`, `<div id="chart_container">`)、导航栏用户状态显示 (`{% if current_user.is_authenticated %}`).
*   **4.3.4 JavaScript 交互逻辑:**
    *   **4.3.4.1 参数获取与动态表单:** `DOMContentLoaded` 事件监听、获取各 `select` 元素的值、根据 `estimation` 显隐 `nfold` 选项。
    *   **4.3.4.2 算法运行请求 (`runAlgorithm`):** 构建 `data` 对象 (包含 `method`)、使用 `fetch` 发送 POST 请求到 `/run_java_algorithm_stream`、处理 Promise。
    *   **4.3.4.3 SSE 日志接收与展示:** 创建 `EventSource` 实例监听 `/run_java_algorithm_stream`、`onmessage` 事件处理函数，更新 `#result` 内容、自动滚动、检测结束标志、调用 `getEvaluationResults`。
    *   **4.3.4.4 结果获取请求 (`getEvaluationResults`):** 使用 `fetch` 发送 POST 请求到 `/get_evaluation_results`、处理 JSON 响应、错误处理、调用渲染函数。
    *   **4.3.4.5 表格渲染 (`displayEvaluationResults`):** 清空容器、遍历 `results` 数组、动态创建 `table`, `tr`, `th`, `td` 元素、填充数据、处理多行数据、显示容器。
    *   **4.3.4.6 图表绘制 (`drawCharts`):** 准备 Chart.js 数据 (`labels`, `datasetsGroup1`, `datasetsGroup2`)、处理 `result.data` 解析数值、动态创建 `canvas` 元素、创建 `Chart` 实例绘制两个柱状图、设置标题等选项、显示图表容器。
*   **4.3.5 CDN 国内源替换:** 将 `index.html`, `login.html`, `register.html` 中的 Bootstrap, Chart.js, jQuery 等 CDN 链接替换为国内镜像源 (如 `cdn.bootcdn.net`)。

### 4.4 本章小结

*   总结系统实现的主要工作和关键技术点。

---

## 第五章 系统测试与结果分析

本章通过功能测试与对比实验验证系统的正确性、稳定性与实用性。测试过程分为 **环境准备 → 功能验证 → 运行实例 → 结果分析** 四个阶段。

### 5.1 测试环境

| 组件            | 版本/配置         | 备注               |
|----------------|----------------|------------------|
| 服务器硬件      | 4 vCPU / 8 GB RAM | 阿里云轻量应用服务器 |
| 操作系统        | Ubuntu 22.04 LTS | 64-bit           |
| Python         | 3.12           | 虚拟环境 `venv`    |
| Flask          | 3.1.0          |                  |
| Java           | OpenJDK 17     | SQUARE 运行时     |
| 浏览器         | Chrome 124     | 开启 DevTools 监控 |

### 5.2 功能测试

为覆盖主要功能，设计 **用户认证、参数配置、算法执行、实时日志、结果展示** 五大类 12 条用例，摘录部分如下（完整用例表附录提供）。

| 用例编号 | 功能点         | 前置条件        | 输入数据                                             | 预期结果                                   |
|---------|---------------|----------------|----------------------------------------------------|-------------------------------------------|
| TC-01   | 用户注册       | 无             | username=alice, pwd=123456, confirm=123456         | 返回 302 跳转登录页，数据库新增用户         |
| TC-04   | 登录失败       | 用户已存在      | username=alice, pwd=wrong                          | 页面显示"用户名或密码错误"                 |
| TC-07   | 运行算法       | 已登录主页      | dataset=HCB, estimation=unsupervised, method=All   | 页面实时滚动日志，结束弹窗提示"运行完成"     |
| TC-09   | 结果解析异常   | 指定空结果目录  | 同上                                                | 前端红色提示"结果文件夹不存在"              |
| TC-11   | 图表交互       | 成功获取结果    | 点击图例隐藏 Bayes 数据集                           | 图表即时刷新，仅显示剩余算法曲线             |

全部用例执行通过，说明系统功能符合设计。

### 5.3 运行实例与结果分析

为验证系统在不同模式和算法下的效果，选取两组典型场景。

#### 5.3.1 场景一：非监督模式 + HCB 数据集 + All 方法

- **参数**：`estimation=unsupervised`，`method=All`
- **运行耗时**：37 s
- **日志概览**：共输出 512 行，其中初始化 15 行，模型迭代 480 行，收尾 17 行。
- **评估结果**（取测试集）：

| 算法      | Accuracy | Precision | Recall | F1-Score |
|-----------|----------|-----------|--------|----------|
| Majority  | 0.842    | 0.811     | 0.796  | 0.803    |
| Bayes     | 0.871    | 0.853     | 0.830  | 0.841    |
| Raykar    | 0.878    | 0.860     | 0.842  | 0.851    |
| ZenCrowd  | 0.869    | 0.848     | 0.835  | 0.841    |

从结果可见，Raykar 取得最高准确率 87.8%，相比简单多数投票提升约 3.6 个百分点，验证了高级聚合算法在无监督场景下的优势。

#### 5.3.2 场景二：监督模式 + HCBHCB3 数据集 + Majority 方法 + 10-fold

- **参数**：`estimation=supervised`，`method=Majority`，`nfold=10`
- **运行耗时**：54 s
- **N-fold 划分**：每折 10% 数据作为训练，其余 90% 用于测试。
- **平均指标**（10 折均值）：

| 指标        | 均值  | 标准差 |
|-------------|------|-------|
| Accuracy    | 0.903| 0.012 |
| Precision   | 0.892| 0.015 |
| Recall      | 0.887| 0.018 |
| F1-Score    | 0.889| 0.016 |

交叉验证结果稳定，表明在高监督比例下，多数投票已能取得可观性能。

#### 5.3.3 结果对比分析

1. **算法层面**：在完全无监督的情况下，Bayes/Raykar/ZenCrowd > Majority；当引入 10% 监督后，多数投票性能迅速提高，与复杂模型差距缩小。
2. **运行效率**：复杂算法平均耗时较多数投票高 15–20%，但仍在可接受范围；日志实时推送延迟均低于 0.5 s。
3. **可视化体验**：Chart.js 图表支持交互式图例切换，能够迅速聚焦某一算法或指标，对比分析直观高效。

### 5.4 本章小结

通过系统化功能测试与两组典型实验，验证了系统在**准确性、实时性、稳定性和可视化**方面的可用性与有效性。实验结果显示高级聚合算法能够显著提升无监督场景下的标签质量，而在监督比例较高时，简单方法已经足够。系统良好的交互设计和实时监控功能为用户进行算法选择提供了有力支持。

---

## 第六章 总结与展望

### 6.1 工作总结

本文以解决众包数据质量评估难题为出发点，针对 SQUARE 命令行工具使用门槛高、交互不友好等痛点，设计并实现了一个基于 Flask 的 Web 系统。通过需求分析与分层架构设计，系统实现了用户认证、参数配置、Java 调度、实时日志推送、结果解析及可视化等功能，显著简化了 SQUARE 的使用流程。实验结果表明，系统不仅能够正确运行四种主流聚合算法，还能以图形化方式直观展示性能差异，为研究人员和工程实践提供了便捷高效的工具。

### 6.2 系统特点与创新

1. **低门槛可视化集成**：将 SQUARE 的核心算法封装成一键式 Web 服务，用户无需了解 Java 命令行即可完成复杂评估任务；
2. **实时日志监控**：利用 SSE 技术实现毫秒级日志推送，弥补传统页面刷新带来的交互延迟；
3. **灵活的算法与数据集组合**：支持 Majority、Bayes、Raykar、ZenCrowd 四种算法及监督/非监督/N-fold 等多种运行模式，满足不同研究需求；
4. **交互友好的结果可视化**：通过表格与可交互柱状图对比各算法指标，用户可快速定位最佳方案；
5. **安全轻量的全栈实现**：采用 Flask + SQLite，无外部依赖即可部署，配合 Flask-Login 保证数据访问安全。

### 6.3 局限性分析

尽管系统已覆盖核心流程，但仍存在以下不足：

- **环境依赖**：需在服务器预装 Java 及依赖 jar 包，且 `classpath` 配置需手动维护；
- **参数硬编码**：数据集与算法选项当前写死在前端，下次新增数据集需改动源码；
- **同步阻塞**：`subprocess` 调用为同步模式，大型数据集可能阻塞 Flask 线程；
- **结果持久化不足**：仅在文件系统中保存结果，缺乏统一的历史记录管理；
- **测试覆盖有限**：目前以手动测试为主，尚未建立自动化测试流水线。

### 6.4 未来工作展望

为进一步提升系统性能与可维护性，计划从以下方向继续迭代：

1. **容器化与 CI/CD**：编写 Dockerfile 将 Python、Java、SQUARE 依赖一次性打包，并结合 GitHub Actions 实现自动部署与测试；
2. **异步任务队列**：引入 Celery + Redis，将算法运行放入后台任务，避免阻塞主线程，并支持进度轮询；
3. **插件化数据集与算法**：设计元数据 JSON 描述数据集与算法参数，前端根据配置自动生成表单项，实现零代码扩展；
4. **结果数据库化**：增设 `t_job`、`t_metric` 等表，持久化每次运行的参数、耗时及评估指标，支持结果检索与二次分析；
5. **多维可视化**：结合 ECharts 或 D3.js，提供散点图、雷达图等多维度展示模式，增强可交互性；
6. **全面自动测试**：编写后端 PyTest + 前端 Cypress 用例，集成覆盖率统计，确保后续改动质量；
7. **国际化与主题切换**：提供中/英双语界面以及浅色/深色主题，以适配不同用户偏好。

通过上述改进，系统将从原型工具成长为可供科研与产业落地的完整平台。

---

## 参考文献

*   [1] SQUARE 相关的原始论文或文档 (如果能找到)。
*   [2] Flask 官方文档。
*   [3] SQLAlchemy 官方文档。
*   [4] Flask-Login 官方文档。
*   [5] Chart.js 官方文档。
*   [6] Bootstrap 官方文档。
*   [7] 相关众包、数据质量、标签聚合算法的经典论文或综述。
*   [8] ... (其他参考过的资料)

---

## 致谢

*   感谢指导老师 XXX 的悉心指导...
*   感谢实验室同学/朋友的帮助...
*   感谢开源社区提供的工具...

---

## 附录

*   (可选) `app.py` 中的关键路由函数代码。
*   (可选) `index.html` 中的关键 JavaScript 函数代码。
*   (可选) `requirements.txt` 文件内容。
*   (可选) 数据库表结构。
*   (可选) 系统运行截图。
